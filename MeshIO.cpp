
#include "MeshIO.h"
#include "Mesh.h"

#include <array>
#include <fstream>
#include <sstream>

namespace rr {

Mesh load_mesh(std::istream& input_file) {
    Mesh  mesh;
    auto& positions      = mesh.positions;
    auto& normals        = mesh.normals;
    auto& uvs            = mesh.uvs;
    auto& position_faces = mesh.position_faces;
    auto& normal_faces   = mesh.normal_faces;
    auto& uv_faces       = mesh.uv_faces;

    std::string line;
    line.reserve(256);
    while (std::getline(input_file, line)) {
        std::istringstream iss(line);
        std::string        token;
        iss >> token;

        if (token == "v") {
            glm::vec3 position;
            iss >> position.x >> position.y >> position.z;
            positions.push_back(position);
        } else if (token == "vt") {
            glm::vec2 uv;
            iss >> uv.x >> uv.y;
            uvs.push_back(uv);
        } else if (token == "vn") {
            glm::vec3 normal;
            iss >> normal.x >> normal.y >> normal.z;
            normals.push_back(normal);
        } else if (token == "f") {
            Mesh::Face pos_face;
            Mesh::Face uv_face;
            Mesh::Face normal_face;
            bool       has_uvs     = false;
            bool       has_normals = false;

            while (iss >> token) {
                std::istringstream vertex_iss(token);
                std::string        index_str;

                std::getline(vertex_iss, index_str, '/');
                pos_face.push_back(std::stoul(index_str) - 1);

                if (std::getline(vertex_iss, index_str, '/')) {
                    if (!index_str.empty()) {
                        uv_face.push_back(std::stoul(index_str) - 1);
                        has_uvs = true;
                    }
                }

                if (std::getline(vertex_iss, index_str, '/')) {
                    if (!index_str.empty()) {
                        normal_face.push_back(std::stoul(index_str) - 1);
                        has_normals = true;
                    }
                }
            }

            position_faces.push_back(pos_face);
            if (has_uvs)
                uv_faces.push_back(uv_face);
            if (has_normals)
                normal_faces.push_back(normal_face);
        }
    }

    return mesh;
}

Mesh load_mesh(std::string_view path) {
    std::ifstream input_file(std::string{path});
    if (!input_file.is_open()) {
        throw std::runtime_error("Failed to open file: " + std::string(path));
    }
    return load_mesh(input_file);
}

void load_mesh(std::string_view path, std::vector<glm::vec3>& positions,
               std::vector<std::array<uint32_t, 3>>& triangles) {
    Mesh mesh = load_mesh(path);
    if (!is_triangulated(mesh)) {
        mesh.triangulate();
    }
    positions = mesh.positions;
    triangles.resize(mesh.position_faces.size());
    for (size_t i = 0; i < mesh.position_faces.size(); ++i) {
        for (size_t j = 0; j < 3; ++j) {
            triangles[i][j] = mesh.position_faces[i][j];
        }
    }
}

void save_obj(std::string_view path, const Mesh& mesh) {
    std::ofstream file(std::string{path});
    if (!file.is_open()) {
        throw std::runtime_error("Failed to open file: " + std::string(path));
    }

    file << "# OBJ file generated by RenderRex\n";

    for (const auto& pos : mesh.positions) {
        file << "v " << pos.x << ' ' << pos.y << ' ' << pos.z << '\n';
    }

    for (const auto& uv : mesh.uvs) {
        file << "vt " << uv.x << ' ' << uv.y << '\n';
    }

    for (const auto& normal : mesh.normals) {
        file << "vn " << normal.x << ' ' << normal.y << ' ' << normal.z << '\n';
    }

    for (size_t i = 0; i < mesh.num_faces(); ++i) {
        file << "f ";
        const auto& pos_face    = mesh.position_faces[i];
        const auto& normal_face = !mesh.normal_faces.empty() ? mesh.normal_faces[i] : Mesh::Face();
        const auto& uv_face     = !mesh.uv_faces.empty() ? mesh.uv_faces[i] : Mesh::Face();

        for (size_t j = 0; j < pos_face.size(); ++j) {
            file << (pos_face[j] + 1);

            if (!mesh.uvs.empty() && !mesh.normals.empty()) {
                // Format: v/vt/vn
                file << '/' << (uv_face[j] + 1) << '/' << (normal_face[j] + 1);
            } else if (!mesh.uvs.empty()) {
                // Format: v/vt
                file << '/' << (uv_face[j] + 1);
            } else if (!mesh.normals.empty()) {
                // Format: v//vn
                file << "//" << (normal_face[j] + 1);
            }

            if (j < pos_face.size() - 1) {
                file << ' ';
            }
        }
        file << '\n';
    }
}

} // namespace rr